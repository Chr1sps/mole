# Specyfikacja języka

## Typy danych

1.
- float (f32)
- double (f64)
2.
- int (i32)
- bool
3.
- char (u8)
4.
- tablice
- string
4.
- wskaźniki (*)
5.
- referencje? (ale niekoniecznie wskaźniki)

## komentarze

// to jest komentarz na jedną linię

/*
to jest komentarz
na kilka linii
*/

## deklaracje zmiennych i stałych

let value = 0; //domyślnie i32
let value: i32 = 0;
let mut value: i32 = 0;
let const value: f32 = 0;

### floaty i double

let value = 0.0; // domyślnie f32
let value = 0f;
let value = 0.0d;

## operacje matematyczne

1. + - * / % ++ --
2. == != > < >= <=
3. ! || && (albo not or and)
3. >> <<
4. += -= itd.
5. ^ 

## deklaracja funkcji

fn no_op() {}
fn no_op() => {}

fn mut foo(x: float, y: float) => float {
	x+y
}

let foo_ptr: fn(float,float) => float = foo;

let func: fn (Vec<float>, float) => Vec<float>;

lambda:
(x, y) => x+y; 

fn add(x: i32, y: i32) => i32 {
	x+y
}

Zamiast:
fn add_one(x: i32) => i32 {
	add(x, 1)
}

Jest:
let add_one = (x) => add(x,1);

A nawet:
let add_one = add(:x:, 1);
let add_one = add(::, 1);

fn add_three_nums(x: i32, y: i32, z: i32): i32 {
	x+y+z
}

let add_two = (x,y) => add_three_nums(x, y, 2);
let add_two = add_three_nums(:x:, :y:, 2);
let add_two = add_three_nums(2, ...);

Gdy nie ma argumentów:

fn return5() => i32 {
	5
}

let add_two = return5;

Problematyczne:
fn return_function() => fn(float) => float { // parser może mieć z tym kłopoty, ale za to JAKI ŁADNY ZAPIS
	(x) => (x+1)
}
// Podobne do haskellowego
// return_function :: _ -> (float -> float)


let func: fn() => fn(float) => float = return_function;
let func: fn() => fn(float) => float = () => fn(float) => float ((x) => float (x+1));

## GRAMATYKA

### Tokeny
Letter = [a-zA-Z];
NonZeroDigit = [1-9];
WhiteSpace = " " | "\t" | "\n";
Digit = 0 | NonZeroDigit;
AlphaNumeric = Letter | Digit;
VarChar = AlphaNumeric | "-" | "_";
LambdaArrow = "=>";
Ellipsis = "...";

Integer = NonZeroDigit, {Digit};
Floating = Digit, ".", [{Digit}];
Float = Floating, ["f"];
Double = Floating, "d";

Identifier = Letter, {AlphaNumeric};
ClosureIdentifier = ":", Identifier, ":";

KeywordFn = "fn";
KeywordExtern = "extern";
KeywordMut = "mut";
KeywordLet = "let";
KeywordConst = "const";
KeywordReturn = "return";
KeywordMain = "main";
KeywordPure = "pure";

### AST
Prototype = KeywordFn, " ", Identifier, "(", [{Identifier, []}]
